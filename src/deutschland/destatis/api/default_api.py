"""
    Destatis-API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from deutschland.destatis.api_client import ApiClient
from deutschland.destatis.api_client import Endpoint as _Endpoint
from deutschland.destatis.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types,
)


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.chart2result_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/chart2result",
                "operation_id": "chart2result",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "charttype",
                    "drawpoints",
                    "zoom",
                    "focus",
                    "tops",
                    "format",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "charttype": (str,),
                    "drawpoints": (str,),
                    "zoom": (str,),
                    "focus": (str,),
                    "tops": (str,),
                    "format": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "charttype": "charttype",
                    "drawpoints": "drawpoints",
                    "zoom": "zoom",
                    "focus": "focus",
                    "tops": "tops",
                    "format": "format",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "charttype": "query",
                    "drawpoints": "query",
                    "zoom": "query",
                    "focus": "query",
                    "tops": "query",
                    "format": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.chart2table_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/chart2table",
                "operation_id": "chart2table",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "charttype",
                    "drawpoints",
                    "zoom",
                    "focus",
                    "tops",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "format",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "charttype": (str,),
                    "drawpoints": (str,),
                    "zoom": (str,),
                    "focus": (str,),
                    "tops": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "format": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "charttype": "charttype",
                    "drawpoints": "drawpoints",
                    "zoom": "zoom",
                    "focus": "focus",
                    "tops": "tops",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "format": "format",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "charttype": "query",
                    "drawpoints": "query",
                    "zoom": "query",
                    "focus": "query",
                    "tops": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "format": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.chart2timeseries_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/chart2timeseries",
                "operation_id": "chart2timeseries",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "charttype",
                    "drawpoints",
                    "zoom",
                    "focus",
                    "tops",
                    "contents",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "format",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "charttype": (str,),
                    "drawpoints": (str,),
                    "zoom": (str,),
                    "focus": (str,),
                    "tops": (str,),
                    "contents": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "format": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "charttype": "charttype",
                    "drawpoints": "drawpoints",
                    "zoom": "zoom",
                    "focus": "focus",
                    "tops": "tops",
                    "contents": "contents",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "format": "format",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "charttype": "query",
                    "drawpoints": "query",
                    "zoom": "query",
                    "focus": "query",
                    "tops": "query",
                    "contents": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "format": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.cube_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/cube",
                "operation_id": "cube",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "values",
                    "metadata",
                    "additionals",
                    "contents",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "format",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "values": (str,),
                    "metadata": (str,),
                    "additionals": (str,),
                    "contents": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "format": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "values": "values",
                    "metadata": "metadata",
                    "additionals": "additionals",
                    "contents": "contents",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "format": "format",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "values": "query",
                    "metadata": "query",
                    "additionals": "query",
                    "contents": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "format": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.cube_meta_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/metadata/cube",
                "operation_id": "cube_meta",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.cubefile_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/cubefile",
                "operation_id": "cubefile",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "values",
                    "metadata",
                    "additionals",
                    "contents",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "format",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "values": (str,),
                    "metadata": (str,),
                    "additionals": (str,),
                    "contents": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "format": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "values": "values",
                    "metadata": "metadata",
                    "additionals": "additionals",
                    "contents": "contents",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "format": "format",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "values": "query",
                    "metadata": "query",
                    "additionals": "query",
                    "contents": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "format": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.cubes_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/cubes",
                "operation_id": "cubes",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "area",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "area": "area",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "area": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.cubes2statistic_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/cubes2statistic",
                "operation_id": "cubes2statistic",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "selection",
                    "area",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "selection": "selection",
                    "area": "area",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "selection": "query",
                    "area": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.cubes2variable_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/cubes2variable",
                "operation_id": "cubes2variable",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "selection",
                    "area",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "selection": "selection",
                    "area": "area",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "selection": "query",
                    "area": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.find_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/find/find",
                "operation_id": "find",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "term",
                    "category",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "term": (str,),
                    "category": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "term": "term",
                    "category": "category",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "term": "query",
                    "category": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.jobs_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/jobs",
                "operation_id": "jobs",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "searchcriterion",
                    "sortcriterion",
                    "type",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "searchcriterion": (str,),
                    "sortcriterion": (str,),
                    "type": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "searchcriterion": "searchcriterion",
                    "sortcriterion": "sortcriterion",
                    "type": "type",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "searchcriterion": "query",
                    "sortcriterion": "query",
                    "type": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.logincheck_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/helloworld/logincheck",
                "operation_id": "logincheck",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.map2result_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/map2result",
                "operation_id": "map2result",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "maptype",
                    "classes",
                    "classification",
                    "zoom",
                    "format",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "maptype": (str,),
                    "classes": (str,),
                    "classification": (str,),
                    "zoom": (str,),
                    "format": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "maptype": "maptype",
                    "classes": "classes",
                    "classification": "classification",
                    "zoom": "zoom",
                    "format": "format",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "maptype": "query",
                    "classes": "query",
                    "classification": "query",
                    "zoom": "query",
                    "format": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.map2table_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/map2table",
                "operation_id": "map2table",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "maptype",
                    "classes",
                    "classification",
                    "zoom",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "format",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "maptype": (str,),
                    "classes": (str,),
                    "classification": (str,),
                    "zoom": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "format": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "maptype": "maptype",
                    "classes": "classes",
                    "classification": "classification",
                    "zoom": "zoom",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "format": "format",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "maptype": "query",
                    "classes": "query",
                    "classification": "query",
                    "zoom": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "format": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.map2timeseries_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/map2timeseries",
                "operation_id": "map2timeseries",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "maptype",
                    "classes",
                    "classification",
                    "zoom",
                    "contents",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "format",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "maptype": (str,),
                    "classes": (str,),
                    "classification": (str,),
                    "zoom": (str,),
                    "contents": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "format": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "maptype": "maptype",
                    "classes": "classes",
                    "classification": "classification",
                    "zoom": "zoom",
                    "contents": "contents",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "format": "format",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "maptype": "query",
                    "classes": "query",
                    "classification": "query",
                    "zoom": "query",
                    "contents": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "format": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.modifieddata_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/modifieddata",
                "operation_id": "modifieddata",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "type",
                    "date",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "type": (str,),
                    "date": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "type": "type",
                    "date": "date",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "type": "query",
                    "date": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.password_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/profile/password",
                "operation_id": "password",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "new",
                    "repeat",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "new": (str,),
                    "repeat": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "new": "new",
                    "repeat": "repeat",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "new": "query",
                    "repeat": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.qualitysigns_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/qualitysigns",
                "operation_id": "qualitysigns",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "language": (str,),
                },
                "attribute_map": {
                    "language": "language",
                },
                "location_map": {
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.remove_result_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/profile/removeResult",
                "operation_id": "remove_result",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.result_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/result",
                "operation_id": "result",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "compress",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "compress": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "compress": "compress",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "compress": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.resultfile_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/resultfile",
                "operation_id": "resultfile",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "compress",
                    "format",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "compress": (str,),
                    "format": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "compress": "compress",
                    "format": "format",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "compress": "query",
                    "format": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.results_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/results",
                "operation_id": "results",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "area",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "area": "area",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "area": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.statistic_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/metadata/statistic",
                "operation_id": "statistic",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.statistics_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/statistics",
                "operation_id": "statistics",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "searchcriterion",
                    "sortcriterion",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "searchcriterion": (str,),
                    "sortcriterion": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "searchcriterion": "searchcriterion",
                    "sortcriterion": "sortcriterion",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "searchcriterion": "query",
                    "sortcriterion": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.statistics2variable_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/statistics2variable",
                "operation_id": "statistics2variable",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "selection",
                    "area",
                    "searchcriterion",
                    "sortcriterion",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "searchcriterion": (str,),
                    "sortcriterion": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "selection": "selection",
                    "area": "area",
                    "searchcriterion": "searchcriterion",
                    "sortcriterion": "sortcriterion",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "selection": "query",
                    "area": "query",
                    "searchcriterion": "query",
                    "sortcriterion": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.table_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/table",
                "operation_id": "table",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "compress",
                    "transpose",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "job",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "compress": (str,),
                    "transpose": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "job": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "compress": "compress",
                    "transpose": "transpose",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "job": "job",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "compress": "query",
                    "transpose": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "job": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.table_meta_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/metadata/table",
                "operation_id": "table_meta",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.tablefile_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/tablefile",
                "operation_id": "tablefile",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "compress",
                    "transpose",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "format",
                    "job",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "compress": (str,),
                    "transpose": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "format": (str,),
                    "job": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "compress": "compress",
                    "transpose": "transpose",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "format": "format",
                    "job": "job",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "compress": "query",
                    "transpose": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "format": "query",
                    "job": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.tables_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/tables",
                "operation_id": "tables",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "area",
                    "searchcriterion",
                    "sortcriterion",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "searchcriterion": (str,),
                    "sortcriterion": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "area": "area",
                    "searchcriterion": "searchcriterion",
                    "sortcriterion": "sortcriterion",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "area": "query",
                    "searchcriterion": "query",
                    "sortcriterion": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.tables2statistic_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/tables2statistic",
                "operation_id": "tables2statistic",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "selection",
                    "area",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "selection": "selection",
                    "area": "area",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "selection": "query",
                    "area": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.tables2variable_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/tables2variable",
                "operation_id": "tables2variable",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "selection",
                    "area",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "selection": "selection",
                    "area": "area",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "selection": "query",
                    "area": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.terms_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/terms",
                "operation_id": "terms",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.timeseries_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/timeseries",
                "operation_id": "timeseries",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "area",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "area": "area",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "area": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.timeseries2statistic_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/timeseries2statistic",
                "operation_id": "timeseries2statistic",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "selection",
                    "area",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "selection": "selection",
                    "area": "area",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "selection": "query",
                    "area": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.timeseries2variable_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/timeseries2variable",
                "operation_id": "timeseries2variable",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "selection",
                    "area",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "selection": "selection",
                    "area": "area",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "selection": "query",
                    "area": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.timeseries_data_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/timeseries",
                "operation_id": "timeseries_data",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "compress",
                    "transpose",
                    "contents",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "regionalkeycode",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingkeycode1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingkeycode2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "classifyingkeycode3",
                    "job",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "compress": (str,),
                    "transpose": (str,),
                    "contents": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "regionalkeycode": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingkeycode1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingkeycode2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "classifyingkeycode3": (str,),
                    "job": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "compress": "compress",
                    "transpose": "transpose",
                    "contents": "contents",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "regionalkeycode": "regionalkeycode",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingkeycode1": "classifyingkeycode1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingkeycode2": "classifyingkeycode2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "classifyingkeycode3": "classifyingkeycode3",
                    "job": "job",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "compress": "query",
                    "transpose": "query",
                    "contents": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "regionalkeycode": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingkeycode1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingkeycode2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "classifyingkeycode3": "query",
                    "job": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.timeseries_meta_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/metadata/timeseries",
                "operation_id": "timeseries_meta",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.timeseriesfile_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/data/timeseriesfile",
                "operation_id": "timeseriesfile",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "compress",
                    "transpose",
                    "contents",
                    "startyear",
                    "endyear",
                    "timeslices",
                    "regionalvariable",
                    "regionalkey",
                    "regionalkeycode",
                    "classifyingvariable1",
                    "classifyingkey1",
                    "classifyingkeycode1",
                    "classifyingvariable2",
                    "classifyingkey2",
                    "classifyingkeycode2",
                    "classifyingvariable3",
                    "classifyingkey3",
                    "classifyingkeycode3",
                    "format",
                    "job",
                    "stand",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "compress": (str,),
                    "transpose": (str,),
                    "contents": (str,),
                    "startyear": (str,),
                    "endyear": (str,),
                    "timeslices": (str,),
                    "regionalvariable": (str,),
                    "regionalkey": (str,),
                    "regionalkeycode": (str,),
                    "classifyingvariable1": (str,),
                    "classifyingkey1": (str,),
                    "classifyingkeycode1": (str,),
                    "classifyingvariable2": (str,),
                    "classifyingkey2": (str,),
                    "classifyingkeycode2": (str,),
                    "classifyingvariable3": (str,),
                    "classifyingkey3": (str,),
                    "classifyingkeycode3": (str,),
                    "format": (str,),
                    "job": (str,),
                    "stand": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "compress": "compress",
                    "transpose": "transpose",
                    "contents": "contents",
                    "startyear": "startyear",
                    "endyear": "endyear",
                    "timeslices": "timeslices",
                    "regionalvariable": "regionalvariable",
                    "regionalkey": "regionalkey",
                    "regionalkeycode": "regionalkeycode",
                    "classifyingvariable1": "classifyingvariable1",
                    "classifyingkey1": "classifyingkey1",
                    "classifyingkeycode1": "classifyingkeycode1",
                    "classifyingvariable2": "classifyingvariable2",
                    "classifyingkey2": "classifyingkey2",
                    "classifyingkeycode2": "classifyingkeycode2",
                    "classifyingvariable3": "classifyingvariable3",
                    "classifyingkey3": "classifyingkey3",
                    "classifyingkeycode3": "classifyingkeycode3",
                    "format": "format",
                    "job": "job",
                    "stand": "stand",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "compress": "query",
                    "transpose": "query",
                    "contents": "query",
                    "startyear": "query",
                    "endyear": "query",
                    "timeslices": "query",
                    "regionalvariable": "query",
                    "regionalkey": "query",
                    "regionalkeycode": "query",
                    "classifyingvariable1": "query",
                    "classifyingkey1": "query",
                    "classifyingkeycode1": "query",
                    "classifyingvariable2": "query",
                    "classifyingkey2": "query",
                    "classifyingkeycode2": "query",
                    "classifyingvariable3": "query",
                    "classifyingkey3": "query",
                    "classifyingkeycode3": "query",
                    "format": "query",
                    "job": "query",
                    "stand": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.value_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/metadata/value",
                "operation_id": "value",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.values_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/values",
                "operation_id": "values",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "area",
                    "searchcriterion",
                    "sortcriterion",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "searchcriterion": (str,),
                    "sortcriterion": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "area": "area",
                    "searchcriterion": "searchcriterion",
                    "sortcriterion": "sortcriterion",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "area": "query",
                    "searchcriterion": "query",
                    "sortcriterion": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.values2variable_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/values2variable",
                "operation_id": "values2variable",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "selection",
                    "area",
                    "searchcriterion",
                    "sortcriterion",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "searchcriterion": (str,),
                    "sortcriterion": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "selection": "selection",
                    "area": "area",
                    "searchcriterion": "searchcriterion",
                    "sortcriterion": "sortcriterion",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "selection": "query",
                    "area": "query",
                    "searchcriterion": "query",
                    "sortcriterion": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.variable_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/metadata/variable",
                "operation_id": "variable",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "area",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "area": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "area": "area",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "area": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.variables_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/variables",
                "operation_id": "variables",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "selection",
                    "area",
                    "searchcriterion",
                    "sortcriterion",
                    "type",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "searchcriterion": (str,),
                    "sortcriterion": (str,),
                    "type": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "selection": "selection",
                    "area": "area",
                    "searchcriterion": "searchcriterion",
                    "sortcriterion": "sortcriterion",
                    "type": "type",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "selection": "query",
                    "area": "query",
                    "searchcriterion": "query",
                    "sortcriterion": "query",
                    "type": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.variables2statistic_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/catalogue/variables2statistic",
                "operation_id": "variables2statistic",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "username",
                    "password",
                    "name",
                    "selection",
                    "area",
                    "searchcriterion",
                    "sortcriterion",
                    "type",
                    "pagelength",
                    "language",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "username": (str,),
                    "password": (str,),
                    "name": (str,),
                    "selection": (str,),
                    "area": (str,),
                    "searchcriterion": (str,),
                    "sortcriterion": (str,),
                    "type": (str,),
                    "pagelength": (str,),
                    "language": (str,),
                },
                "attribute_map": {
                    "username": "username",
                    "password": "password",
                    "name": "name",
                    "selection": "selection",
                    "area": "area",
                    "searchcriterion": "searchcriterion",
                    "sortcriterion": "sortcriterion",
                    "type": "type",
                    "pagelength": "pagelength",
                    "language": "language",
                },
                "location_map": {
                    "username": "query",
                    "password": "query",
                    "name": "query",
                    "selection": "query",
                    "area": "query",
                    "searchcriterion": "query",
                    "sortcriterion": "query",
                    "type": "query",
                    "pagelength": "query",
                    "language": "query",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )
        self.whoami_endpoint = _Endpoint(
            settings={
                "response_type": None,
                "auth": [],
                "endpoint_path": "/helloworld/whoami",
                "operation_id": "whoami",
                "http_method": "GET",
                "servers": None,
            },
            params_map={
                "all": [
                    "user_agent",
                ],
                "required": [],
                "nullable": [],
                "enum": [],
                "validation": [],
            },
            root_map={
                "validations": {},
                "allowed_values": {},
                "openapi_types": {
                    "user_agent": (str,),
                },
                "attribute_map": {
                    "user_agent": "user-agent",
                },
                "location_map": {
                    "user_agent": "header",
                },
                "collection_format_map": {},
            },
            headers_map={
                "accept": [],
                "content_type": [],
            },
            api_client=api_client,
        )

    def chart2result(self, **kwargs):
        """chart2result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.chart2result(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            charttype (str): [optional] if omitted the server will use the default value of "0"
            drawpoints (str): [optional] if omitted the server will use the default value of "false"
            zoom (str): [optional] if omitted the server will use the default value of "2"
            focus (str): [optional] if omitted the server will use the default value of "false"
            tops (str): [optional] if omitted the server will use the default value of "false"
            format (str): [optional] if omitted the server will use the default value of "png"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.chart2result_endpoint.call_with_http_info(**kwargs)

    def chart2table(self, **kwargs):
        """chart2table  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.chart2table(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            charttype (str): [optional] if omitted the server will use the default value of "0"
            drawpoints (str): [optional] if omitted the server will use the default value of "false"
            zoom (str): [optional] if omitted the server will use the default value of "2"
            focus (str): [optional] if omitted the server will use the default value of "false"
            tops (str): [optional] if omitted the server will use the default value of "false"
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            format (str): [optional] if omitted the server will use the default value of "png"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.chart2table_endpoint.call_with_http_info(**kwargs)

    def chart2timeseries(self, **kwargs):
        """chart2timeseries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.chart2timeseries(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            charttype (str): [optional] if omitted the server will use the default value of "0"
            drawpoints (str): [optional] if omitted the server will use the default value of "false"
            zoom (str): [optional] if omitted the server will use the default value of "2"
            focus (str): [optional] if omitted the server will use the default value of "false"
            tops (str): [optional] if omitted the server will use the default value of "false"
            contents (str): [optional]
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            format (str): [optional] if omitted the server will use the default value of "png"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.chart2timeseries_endpoint.call_with_http_info(**kwargs)

    def cube(self, **kwargs):
        """cube  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cube(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            values (str): [optional] if omitted the server will use the default value of "true"
            metadata (str): [optional] if omitted the server will use the default value of "false"
            additionals (str): [optional] if omitted the server will use the default value of "false"
            contents (str): [optional]
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            format (str): [optional] if omitted the server will use the default value of "csv"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.cube_endpoint.call_with_http_info(**kwargs)

    def cube_meta(self, **kwargs):
        """cube_meta  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cube_meta(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.cube_meta_endpoint.call_with_http_info(**kwargs)

    def cubefile(self, **kwargs):
        """cubefile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cubefile(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            values (str): [optional] if omitted the server will use the default value of "true"
            metadata (str): [optional] if omitted the server will use the default value of "false"
            additionals (str): [optional] if omitted the server will use the default value of "false"
            contents (str): [optional]
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            format (str): [optional] if omitted the server will use the default value of "csv"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.cubefile_endpoint.call_with_http_info(**kwargs)

    def cubes(self, **kwargs):
        """cubes  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cubes(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.cubes_endpoint.call_with_http_info(**kwargs)

    def cubes2statistic(self, **kwargs):
        """cubes2statistic  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cubes2statistic(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.cubes2statistic_endpoint.call_with_http_info(**kwargs)

    def cubes2variable(self, **kwargs):
        """cubes2variable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cubes2variable(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.cubes2variable_endpoint.call_with_http_info(**kwargs)

    def find(self, **kwargs):
        """find  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            term (str): [optional]
            category (str): [optional] if omitted the server will use the default value of "all"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.find_endpoint.call_with_http_info(**kwargs)

    def jobs(self, **kwargs):
        """jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.jobs(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            searchcriterion (str): [optional] if omitted the server will use the default value of "Code"
            sortcriterion (str): [optional] if omitted the server will use the default value of "Name"
            type (str): [optional] if omitted the server will use the default value of "Alle"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.jobs_endpoint.call_with_http_info(**kwargs)

    def logincheck(self, **kwargs):
        """logincheck  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.logincheck(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional]
            password (str): [optional]
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.logincheck_endpoint.call_with_http_info(**kwargs)

    def map2result(self, **kwargs):
        """map2result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.map2result(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            maptype (str): [optional] if omitted the server will use the default value of "0"
            classes (str): [optional] if omitted the server will use the default value of "5"
            classification (str): [optional] if omitted the server will use the default value of "0"
            zoom (str): [optional] if omitted the server will use the default value of "2"
            format (str): [optional] if omitted the server will use the default value of "png"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.map2result_endpoint.call_with_http_info(**kwargs)

    def map2table(self, **kwargs):
        """map2table  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.map2table(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            maptype (str): [optional] if omitted the server will use the default value of "0"
            classes (str): [optional] if omitted the server will use the default value of "5"
            classification (str): [optional] if omitted the server will use the default value of "0"
            zoom (str): [optional] if omitted the server will use the default value of "2"
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            format (str): [optional] if omitted the server will use the default value of "png"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.map2table_endpoint.call_with_http_info(**kwargs)

    def map2timeseries(self, **kwargs):
        """map2timeseries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.map2timeseries(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            maptype (str): [optional] if omitted the server will use the default value of "0"
            classes (str): [optional] if omitted the server will use the default value of "5"
            classification (str): [optional] if omitted the server will use the default value of "0"
            zoom (str): [optional] if omitted the server will use the default value of "2"
            contents (str): [optional]
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            format (str): [optional] if omitted the server will use the default value of "png"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.map2timeseries_endpoint.call_with_http_info(**kwargs)

    def modifieddata(self, **kwargs):
        """modifieddata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.modifieddata(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            type (str): [optional] if omitted the server will use the default value of "Alle"
            date (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.modifieddata_endpoint.call_with_http_info(**kwargs)

    def password(self, **kwargs):
        """password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.password(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional]
            password (str): [optional]
            new (str): [optional]
            repeat (str): [optional]
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.password_endpoint.call_with_http_info(**kwargs)

    def qualitysigns(self, **kwargs):
        """qualitysigns  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.qualitysigns(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.qualitysigns_endpoint.call_with_http_info(**kwargs)

    def remove_result(self, **kwargs):
        """remove_result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.remove_result(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.remove_result_endpoint.call_with_http_info(**kwargs)

    def result(self, **kwargs):
        """result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.result(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            compress (str): [optional] if omitted the server will use the default value of "false"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.result_endpoint.call_with_http_info(**kwargs)

    def resultfile(self, **kwargs):
        """resultfile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.resultfile(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            compress (str): [optional] if omitted the server will use the default value of "false"
            format (str): [optional] if omitted the server will use the default value of "csv"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.resultfile_endpoint.call_with_http_info(**kwargs)

    def results(self, **kwargs):
        """results  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.results(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.results_endpoint.call_with_http_info(**kwargs)

    def statistic(self, **kwargs):
        """statistic  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.statistic(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.statistic_endpoint.call_with_http_info(**kwargs)

    def statistics(self, **kwargs):
        """statistics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.statistics(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            searchcriterion (str): [optional] if omitted the server will use the default value of "Code"
            sortcriterion (str): [optional] if omitted the server will use the default value of "Name"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.statistics_endpoint.call_with_http_info(**kwargs)

    def statistics2variable(self, **kwargs):
        """statistics2variable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.statistics2variable(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            searchcriterion (str): [optional] if omitted the server will use the default value of "Code"
            sortcriterion (str): [optional] if omitted the server will use the default value of "Name"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.statistics2variable_endpoint.call_with_http_info(**kwargs)

    def table(self, **kwargs):
        """table  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.table(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            compress (str): [optional] if omitted the server will use the default value of "false"
            transpose (str): [optional] if omitted the server will use the default value of "false"
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            job (str): [optional] if omitted the server will use the default value of "false"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.table_endpoint.call_with_http_info(**kwargs)

    def table_meta(self, **kwargs):
        """table_meta  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.table_meta(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.table_meta_endpoint.call_with_http_info(**kwargs)

    def tablefile(self, **kwargs):
        """tablefile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tablefile(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            compress (str): [optional] if omitted the server will use the default value of "false"
            transpose (str): [optional] if omitted the server will use the default value of "false"
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            format (str): [optional] if omitted the server will use the default value of "csv"
            job (str): [optional] if omitted the server will use the default value of "false"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.tablefile_endpoint.call_with_http_info(**kwargs)

    def tables(self, **kwargs):
        """tables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tables(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            searchcriterion (str): [optional] if omitted the server will use the default value of "Code"
            sortcriterion (str): [optional] if omitted the server will use the default value of "Code"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.tables_endpoint.call_with_http_info(**kwargs)

    def tables2statistic(self, **kwargs):
        """tables2statistic  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tables2statistic(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.tables2statistic_endpoint.call_with_http_info(**kwargs)

    def tables2variable(self, **kwargs):
        """tables2variable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tables2variable(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.tables2variable_endpoint.call_with_http_info(**kwargs)

    def terms(self, **kwargs):
        """terms  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.terms(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.terms_endpoint.call_with_http_info(**kwargs)

    def timeseries(self, **kwargs):
        """timeseries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.timeseries(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.timeseries_endpoint.call_with_http_info(**kwargs)

    def timeseries2statistic(self, **kwargs):
        """timeseries2statistic  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.timeseries2statistic(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.timeseries2statistic_endpoint.call_with_http_info(**kwargs)

    def timeseries2variable(self, **kwargs):
        """timeseries2variable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.timeseries2variable(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.timeseries2variable_endpoint.call_with_http_info(**kwargs)

    def timeseries_data(self, **kwargs):
        """timeseries_data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.timeseries_data(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            compress (str): [optional] if omitted the server will use the default value of "false"
            transpose (str): [optional] if omitted the server will use the default value of "false"
            contents (str): [optional]
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            regionalkeycode (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingkeycode1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingkeycode2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            classifyingkeycode3 (str): [optional]
            job (str): [optional] if omitted the server will use the default value of "false"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.timeseries_data_endpoint.call_with_http_info(**kwargs)

    def timeseries_meta(self, **kwargs):
        """timeseries_meta  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.timeseries_meta(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.timeseries_meta_endpoint.call_with_http_info(**kwargs)

    def timeseriesfile(self, **kwargs):
        """timeseriesfile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.timeseriesfile(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            compress (str): [optional] if omitted the server will use the default value of "false"
            transpose (str): [optional] if omitted the server will use the default value of "false"
            contents (str): [optional]
            startyear (str): [optional]
            endyear (str): [optional]
            timeslices (str): [optional]
            regionalvariable (str): [optional]
            regionalkey (str): [optional]
            regionalkeycode (str): [optional]
            classifyingvariable1 (str): [optional]
            classifyingkey1 (str): [optional]
            classifyingkeycode1 (str): [optional]
            classifyingvariable2 (str): [optional]
            classifyingkey2 (str): [optional]
            classifyingkeycode2 (str): [optional]
            classifyingvariable3 (str): [optional]
            classifyingkey3 (str): [optional]
            classifyingkeycode3 (str): [optional]
            format (str): [optional] if omitted the server will use the default value of "csv"
            job (str): [optional] if omitted the server will use the default value of "false"
            stand (str): [optional] if omitted the server will use the default value of "01.01.1970 01:00"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.timeseriesfile_endpoint.call_with_http_info(**kwargs)

    def value(self, **kwargs):
        """value  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.value(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.value_endpoint.call_with_http_info(**kwargs)

    def values(self, **kwargs):
        """values  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.values(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            searchcriterion (str): [optional] if omitted the server will use the default value of "Code"
            sortcriterion (str): [optional] if omitted the server will use the default value of "Name"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.values_endpoint.call_with_http_info(**kwargs)

    def values2variable(self, **kwargs):
        """values2variable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.values2variable(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            searchcriterion (str): [optional] if omitted the server will use the default value of "Code"
            sortcriterion (str): [optional] if omitted the server will use the default value of "Name"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.values2variable_endpoint.call_with_http_info(**kwargs)

    def variable(self, **kwargs):
        """variable  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.variable(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.variable_endpoint.call_with_http_info(**kwargs)

    def variables(self, **kwargs):
        """variables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.variables(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            searchcriterion (str): [optional] if omitted the server will use the default value of "Code"
            sortcriterion (str): [optional] if omitted the server will use the default value of "Name"
            type (str): [optional] if omitted the server will use the default value of "Alle"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.variables_endpoint.call_with_http_info(**kwargs)

    def variables2statistic(self, **kwargs):
        """variables2statistic  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.variables2statistic(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            username (str): [optional] if omitted the server will use the default value of "GAST"
            password (str): [optional] if omitted the server will use the default value of "GAST"
            name (str): [optional]
            selection (str): [optional]
            area (str): [optional] if omitted the server will use the default value of "free"
            searchcriterion (str): [optional] if omitted the server will use the default value of "Code"
            sortcriterion (str): [optional] if omitted the server will use the default value of "Name"
            type (str): [optional] if omitted the server will use the default value of "Alle"
            pagelength (str): [optional] if omitted the server will use the default value of "100"
            language (str): [optional] if omitted the server will use the default value of "de"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.variables2statistic_endpoint.call_with_http_info(**kwargs)

    def whoami(self, **kwargs):
        """whoami  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.whoami(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            user_agent (str): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs["async_req"] = kwargs.get("async_req", False)
        kwargs["_return_http_data_only"] = kwargs.get("_return_http_data_only", True)
        kwargs["_preload_content"] = kwargs.get("_preload_content", True)
        kwargs["_request_timeout"] = kwargs.get("_request_timeout", None)
        kwargs["_check_input_type"] = kwargs.get("_check_input_type", True)
        kwargs["_check_return_type"] = kwargs.get("_check_return_type", True)
        kwargs["_host_index"] = kwargs.get("_host_index")
        return self.whoami_endpoint.call_with_http_info(**kwargs)
